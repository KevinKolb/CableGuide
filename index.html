<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Cable Guide Channel</title>
<script>
/* ============================================================================
   CONFIGURATION
   ============================================================================ */
const API_KEY = "f60c4964b9cbd51e78e0b1739b00775b"; // keep this file private

/* ============================================================================
   INITIALIZATION
   ============================================================================ */
document.addEventListener("DOMContentLoaded", () => {
    loadGuide();
    updateClock();
    setInterval(updateClock, 1000);
    updateVisitorCount();
});

/* ============================================================================
   CLOCK FUNCTIONALITY
   ============================================================================ */
function updateClock() {
    const clock = document.getElementById("clock");
    const now = new Date();
    clock.textContent = now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
}

/* ============================================================================
   VISITOR COUNTER
   ============================================================================ */
function updateVisitorCount() {
    // Get current visitor count from localStorage
    let visitorCount = localStorage.getItem('cableGuideVisitors');

    if (visitorCount === null) {
        // First time visitor
        visitorCount = 1;
    } else {
        // Increment visitor count
        visitorCount = parseInt(visitorCount) + 1;
    }

    // Save updated count
    localStorage.setItem('cableGuideVisitors', visitorCount);

    // Display the count
    const visitorElement = document.getElementById('visitorCount');
    if (visitorElement) {
        visitorElement.textContent = visitorCount;
    }
}

/* ============================================================================
   TIME FORMATTING UTILITIES
   ============================================================================ */
function formatTimeLabel(timeString) {
    const [hours, minutes] = timeString.split(":");
    let h = parseInt(hours, 10);
    const ampm = h >= 12 ? "PM" : "AM";
    h = h % 12 || 12;
    return `${h}:${minutes} ${ampm}`;
}

/* ============================================================================
   GUIDE DATA LOADING
   Loads channel data from XML (scraped) and API sources, merges them
   ============================================================================ */
async function loadGuide() {
    try {
        // STEP 1: Load guide.xml first (scraped channels - highest priority)
        let xmlChannels = [];
        try {
            const xmlRes = await fetch("guide.xml");
            if (xmlRes.ok) {
                const xmlText = await xmlRes.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");

                const channelElements = xmlDoc.querySelectorAll("channel");
                xmlChannels = Array.from(channelElements).map(ch => {
                    const number = ch.querySelector("number")?.textContent || "";
                    const name = ch.querySelector("name")?.textContent || "";
                    const shows = Array.from(ch.querySelectorAll("show")).map(show => ({
                        start: show.getAttribute("start"),
                        duration: parseInt(show.getAttribute("duration") || "30"),
                        title: show.textContent,
                        description: show.getAttribute("description") || ""
                    }));

                    return {
                        channelNumber: number,
                        callSign: name,
                        network: name,
                        listings: shows.map(show => ({
                            title: show.title,
                            shortDescription: show.description,
                            startTime: new Date(), // Will be calculated from time slots
                            duration: show.duration
                        })),
                        source: "xml" // Mark as scraped channel
                    };
                });
                console.log(`üìÑ Loaded ${xmlChannels.length} channels from guide.xml`);
            }
        } catch (xmlErr) {
            console.log("‚ö†Ô∏è Could not load guide.xml, using API only");
        }

        const zip = "70130"; // New Orleans

        // STEP 2: Get lineups for your ZIP
        const lineupRes = await fetch(
            `https://api.tvmedia.ca/tv/v4/lineups?postalCode=${encodeURIComponent(zip)}&api_key=${API_KEY}`
        );
        if (!lineupRes.ok) throw new Error("Failed to fetch lineups");
        const lineups = await lineupRes.json();
        if (!Array.isArray(lineups) || lineups.length === 0) {
            throw new Error("No lineups returned for this ZIP");
        }

        const lineupID = lineups[0].lineupID;

        // STEP 3: Get grid listings for that lineup (API channels)
        const listingsRes = await fetch(
            `https://api.tvmedia.ca/tv/v4/lineups/${encodeURIComponent(lineupID)}/listings/grid?api_key=${API_KEY}`
        );
        if (!listingsRes.ok) throw new Error("Failed to fetch listings grid");

        const grid = await listingsRes.json();
        let apiChannels = Array.isArray(grid.channels) ? grid.channels : [];

        // Filter API channels that have listings
        apiChannels = apiChannels.filter(ch => {
            const listings = Array.isArray(ch.listings) ? ch.listings : [];
            return listings.length > 0;
        }).map(ch => ({
            ...ch,
            source: "api" // Mark as API channel
        }));

        console.log(`üåê Loaded ${apiChannels.length} channels from API`);

        // STEP 4: Merge channels - XML channels override API channels with same call sign/network
        const channelMap = new Map();

        // First, add all API channels
        apiChannels.forEach(ch => {
            const key = (ch.callSign || ch.network || ch.networkName || "").toUpperCase().replace(/[^A-Z0-9]/g, '');
            if (key) {
                channelMap.set(key, ch);
            }
        });

        // Then, override with XML channels (higher priority)
        xmlChannels.forEach(ch => {
            const key = (ch.callSign || ch.network || "").toUpperCase().replace(/[^A-Z0-9]/g, '');
            if (key) {
                if (channelMap.has(key)) {
                    console.log(`üîÑ Overriding API channel ${key} with scraped data`);
                }
                channelMap.set(key, ch);
            }
        });

        // Convert back to array
        let channels = Array.from(channelMap.values());

        // Sort by channel number for better organization
        channels.sort((a, b) => {
            const numA = parseInt(a.channelNumber) || 0;
            const numB = parseInt(b.channelNumber) || 0;
            return numA - numB;
        });

        if (channels.length === 0) {
            throw new Error("No channels in grid response");
        }

        console.log(`‚úÖ Total ${channels.length} channels (${xmlChannels.length} scraped, ${apiChannels.length} API)`);

        // STEP 5: Load clickable ads from XML (if available) - Show one random ad
        try {
            const xmlRes = await fetch("guide.xml");
            if (xmlRes.ok) {
                const xmlText = await xmlRes.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                const ads = xmlDoc.querySelectorAll("ads ad");

                if (ads.length > 0) {
                    const adsContainer = document.getElementById("adsContainer");

                    // Pick a random ad
                    const randomIndex = Math.floor(Math.random() * ads.length);
                    const randomAd = ads[randomIndex];

                    const url = randomAd.getAttribute("url");
                    let image = randomAd.getAttribute("image");
                    const alt = randomAd.getAttribute("alt") || randomAd.textContent;
                    const title = randomAd.textContent;

                    // Check if image is a local path (doesn't start with http)
                    if (image && !image.startsWith('http')) {
                        image = `ads/${image}`;
                    }

                    const adHTML = `
                        <a href="${url}" class="ad-item" target="_blank" rel="noopener noreferrer">
                            <img src="${image}" alt="${alt}" />
                            <div class="ad-item-title">${title}</div>
                        </a>`;

                    adsContainer.innerHTML = `<div class="ads-carousel">${adHTML}</div>`;
                    adsContainer.classList.add('has-ads');
                    console.log(`üì¢ Loaded 1 random ad from ${ads.length} available ads in guide.xml`);
                }
            }
        } catch (err) {
            console.log("‚ö†Ô∏è No clickable ads found in guide.xml");
        }

        // STEP 6: YouTube videos section removed

        // STEP 7: Build header - ad banner, date, and time slots
        updateChannelCount(channels.length);

        function updateChannelCount(total) {
            document.getElementById("adSection").innerHTML =
                `<div class="ad-text">CABLE TV GUIDE ‚Äì <span id="visibleChannelCount">${total}</span> / ${total} CHANNELS</div>`;
        }

        // Store for later use
        window.updateChannelCount = updateChannelCount;
        window.totalChannels = channels.length;

        const today = new Date();
        const dateLabel = today.toLocaleDateString(undefined, {
            weekday: "short",
            month: "short",
            day: "numeric"
        });
        document.getElementById("dateDisplay").textContent = dateLabel;
        document.getElementById("guideHeader").style.display = "flex";

        // Build 8 x 30-minute time slots starting from current half-hour
        const timeSlotsEl = document.getElementById("timeSlots");
        const now = new Date();
        const start = new Date(now);
        start.setMinutes(now.getMinutes() < 30 ? 0 : 30, 0, 0);

        let timeHTML = "";
        for (let i = 0; i < 8; i++) {
            const slotTime = new Date(start.getTime() + i * 30 * 60000);
            const hh = String(slotTime.getHours()).padStart(2, "0");
            const mm = String(slotTime.getMinutes()).padStart(2, "0");
            const label = formatTimeLabel(`${hh}:${mm}`);
            timeHTML += `<div class="time-slot">${label}</div>`;
        }
        timeSlotsEl.innerHTML = timeHTML;

        // STEP 8: Build channel filter checkboxes
        const filtersEl = document.getElementById("channelFilters");
        const filterHTML = channels.map((ch, idx) => {
            const number = ch.channelNumber || "";
            const callSign = ch.callSign || "";
            const network = ch.network || ch.networkName || "";
            const label = [number, callSign || network].filter(Boolean).join(" - ");
            return `
                <div class="filter-item">
                    <input type="checkbox" checked id="filter-${idx}" onchange="toggleChannel(${idx})">
                    <label for="filter-${idx}">${label}</label>
                </div>`;
        }).join("");
        filtersEl.innerHTML = filterHTML;

        // STEP 9: Build guide rows (channel listings)
        const guideScroll = document.getElementById("guideScroll");
        guideScroll.innerHTML = "";

        const guideHTML = channels.map(ch => {
            const number = ch.channelNumber || "";
            const callSign = ch.callSign || "";
            const network = ch.network || ch.networkName || "";
            const channelLabel = callSign || network || number;
            const listings = Array.isArray(ch.listings) ? ch.listings : [];

            const showsHTML = listings.map(listing => {
                const startTime = new Date(listing.startTime);
                const endTime = listing.endTime
                    ? new Date(listing.endTime)
                    : new Date(startTime.getTime() + (listing.duration || 30) * 60000);

                const durationMin = Math.max(15, (endTime - startTime) / 60000); // clamp a bit
                const widthPx = (durationMin / 30) * 140;

                const title =
                    listing.title ||
                    listing.episodeTitle ||
                    listing.seriesTitle ||
                    "Program";

                // Build more detailed description
                let desc = listing.shortDescription || listing.longDescription || "";

                // Add episode info if available
                if (listing.episodeTitle && listing.episodeTitle !== title) {
                    desc = `${listing.episodeTitle}. ${desc}`;
                }
                if (listing.seasonNumber && listing.episodeNumber) {
                    desc = `S${listing.seasonNumber}E${listing.episodeNumber} - ${desc}`;
                }

                // Add rating and year if available
                const extras = [];
                if (listing.rating) extras.push(listing.rating);
                if (listing.year) extras.push(listing.year);
                if (extras.length > 0) {
                    desc = `${desc} (${extras.join(', ')})`;
                }

                const safeDescription = desc
                    .replace(/&/g, "&amp;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");

                const tooltipAttr = safeDescription
                    ? ` data-description="${safeDescription}"`
                    : "";

                return `
                    <div class="show-block"
                         style="min-width:${widthPx}px"
                         ${tooltipAttr}>
                        ${title}
                    </div>`;
            }).join("");

            // Add source indicator
            const sourceIcon = ch.source === "xml" ? "‚≠ê" : "";
            const sourceTitle = ch.source === "xml"
                ? `${channelLabel} (Scraped from source)`
                : channelLabel;

            return `
                <div class="channel-row" data-source="${ch.source || 'api'}">
                    <div class="channel-number" title="${sourceTitle}">${sourceIcon}${number}</div>
                    <div class="shows-container">
                        ${showsHTML}
                    </div>
                </div>`;
        }).join("");

        // STEP 10: Duplicate content for seamless infinite scroll
        guideScroll.innerHTML = guideHTML + guideHTML;

        // STEP 11: Initialize auto-scroll and drag functionality
        initializeScrolling();

    } catch (err) {
        console.error(err);
        document.getElementById("adSection").innerHTML =
            '<div class="loading">ERROR LOADING GUIDE DATA</div>';
    }
}

/* ============================================================================
   AUTO-SCROLL AND DRAG FUNCTIONALITY
   Provides infinite auto-scrolling with click-and-drag manual control
   ============================================================================ */

// Auto-scroll configuration
let autoScrollSpeed = 0.5; // pixels per frame
let scrollAnimationId = null;

// Drag state
let isDragging = false;
let startY = 0;
let scrollTop = 0;

function initializeScrolling() {
    const container = document.querySelector('.guide-container');
    const guideScroll = document.getElementById('guideScroll');

    if (!container || !guideScroll) return;

    // Auto-scroll animation loop
    function autoScroll() {
        if (!isDragging) {
            container.scrollTop += autoScrollSpeed;

            // Infinite loop: reset to beginning when halfway through duplicated content
            const halfHeight = guideScroll.scrollHeight / 2;
            if (container.scrollTop >= halfHeight) {
                container.scrollTop = 0;
            }
        }
        scrollAnimationId = requestAnimationFrame(autoScroll);
    }

    // Start auto-scroll animation
    if (scrollAnimationId) {
        cancelAnimationFrame(scrollAnimationId);
    }
    autoScroll();

    // Mouse down: start dragging
    container.addEventListener('mousedown', (e) => {
        isDragging = true;
        startY = e.pageY - container.offsetTop;
        scrollTop = container.scrollTop;
        container.classList.add('dragging');
    });

    // Mouse leave: stop dragging
    container.addEventListener('mouseleave', () => {
        isDragging = false;
        container.classList.remove('dragging');
    });

    // Mouse up: stop dragging
    container.addEventListener('mouseup', () => {
        isDragging = false;
        container.classList.remove('dragging');
    });

    // Mouse move: handle dragging
    container.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();

        const y = e.pageY - container.offsetTop;
        const walk = (y - startY) * 2; // Scroll speed multiplier
        container.scrollTop = scrollTop - walk;

        // Maintain infinite loop during drag
        const halfHeight = guideScroll.scrollHeight / 2;
        if (container.scrollTop >= halfHeight) {
            // Scrolled past halfway, jump back to start
            container.scrollTop = container.scrollTop - halfHeight;
            scrollTop = container.scrollTop;
            startY = y;
        } else if (container.scrollTop < 0) {
            // Scrolled before start, jump to halfway point
            container.scrollTop = halfHeight + container.scrollTop;
            scrollTop = container.scrollTop;
            startY = y;
        }
    });
}

/* ============================================================================
   UI CONTROLS
   Toggle channel visibility and control panel collapse
   ============================================================================ */

function toggleChannel(idx) {
    const rows = document.querySelectorAll(".channel-row");
    const totalChannels = rows.length / 2; // Half because content is duplicated

    // Toggle both the original row and its duplicate
    if (rows[idx]) {
        rows[idx].classList.toggle("hidden");
    }
    // Toggle the duplicate row (second half)
    if (rows[idx + totalChannels]) {
        rows[idx + totalChannels].classList.toggle("hidden");
    }

    // Update visible channel count
    updateVisibleChannelCount();
}

function updateVisibleChannelCount() {
    const allRows = document.querySelectorAll(".channel-row");
    const totalRows = allRows.length / 2; // Divided by 2 because content is duplicated
    const visibleRows = Array.from(allRows).slice(0, totalRows).filter(row => !row.classList.contains("hidden")).length;

    const countElement = document.getElementById("visibleChannelCount");
    if (countElement) {
        countElement.textContent = visibleRows;
    }
}

function toggleControls() {
    const panel = document.getElementById("controlsPanel");
    panel.classList.toggle("collapsed");
}

/* ============================================================================
   FULLSCREEN FUNCTIONALITY
   Toggle fullscreen mode for the TV guide container
   ============================================================================ */
function toggleFullscreen() {
    const container = document.querySelector('.tv-container');
    const btn = document.getElementById('fullscreenBtn');

    if (!document.fullscreenElement &&
        !document.webkitFullscreenElement &&
        !document.mozFullScreenElement &&
        !document.msFullscreenElement) {

        // Enter fullscreen
        if (container.requestFullscreen) {
            container.requestFullscreen();
        } else if (container.webkitRequestFullscreen) {
            container.webkitRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
            container.mozRequestFullScreen();
        } else if (container.msRequestFullscreen) {
            container.msRequestFullscreen();
        }

        // Update button icon
        btn.querySelector('.fullscreen-icon').textContent = '‚õ∂';
        btn.title = 'Exit Fullscreen';

    } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }

        // Update button icon
        btn.querySelector('.fullscreen-icon').textContent = '‚õ∂';
        btn.title = 'Toggle Fullscreen';
    }
}

// Listen for fullscreen changes (e.g., when user presses ESC)
document.addEventListener('fullscreenchange', updateFullscreenButton);
document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
document.addEventListener('mozfullscreenchange', updateFullscreenButton);
document.addEventListener('MSFullscreenChange', updateFullscreenButton);

function updateFullscreenButton() {
    const btn = document.getElementById('fullscreenBtn');
    if (!btn) return;

    const isFullscreen = document.fullscreenElement ||
                        document.webkitFullscreenElement ||
                        document.mozFullScreenElement ||
                        document.msFullscreenElement;

    if (isFullscreen) {
        btn.querySelector('.fullscreen-icon').textContent = '‚õ∂';
        btn.title = 'Exit Fullscreen (ESC)';
    } else {
        btn.querySelector('.fullscreen-icon').textContent = '‚õ∂';
        btn.title = 'Toggle Fullscreen';
    }
}
</script>
</head>
<body>
    <!-- ========================================
         CHANNEL FILTERS SECTION
         Collapsible panel for toggling channels
         ======================================== -->
    <div class="controls" id="controlsPanel">
        <div class="controls-header" onclick="toggleControls()">
            <h3>
                <span>üéõÔ∏è</span>
                <span>CHANNELS</span>
            </h3>
            <span class="toggle-arrow">‚ñº</span>
        </div>
        <div class="channel-filters" id="channelFilters">
            <!-- Channel checkboxes populated dynamically -->
        </div>
    </div>

    <!-- ========================================
         TV GUIDE SECTION
         Main guide display with auto-scroll
         ======================================== -->
    <div class="tv-container">
        <div class="screen">
            <!-- Visual effects overlay -->
            <div class="scanlines"></div>

            <!-- Top-right clock -->
            <div class="clock" id="clock"></div>

            <!-- Fullscreen button -->
            <button class="fullscreen-btn" id="fullscreenBtn" onclick="toggleFullscreen()" title="Toggle Fullscreen">
                <span class="fullscreen-icon">‚õ∂</span>
            </button>

            <!-- Advertisement/status banner -->
            <div class="ad-section" id="adSection">
                <div class="loading">LOADING GUIDE DATA...</div>
            </div>

            <!-- Clickable ads carousel -->
            <div class="ads-container" id="adsContainer">
                <!-- Clickable ads populated dynamically from XML -->
            </div>


            <!-- Date and time slots header -->
            <div class="guide-header" id="guideHeader" style="display: none;">
                <div class="date-display" id="dateDisplay"></div>
                <div class="time-slots-container">
                    <div class="time-slots" id="timeSlots">
                        <!-- Time slots populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- Main scrollable guide container -->
            <!-- Features: auto-scroll, infinite loop, click-and-drag -->
            <div class="guide-container">
                <div class="guide-scroll" id="guideScroll">
                    <!-- Channel rows populated dynamically -->
                    <!-- Content is duplicated for seamless infinite scroll -->
                </div>
            </div>
        </div>
    </div>

    <!-- ========================================
         FOOTER
         Developer credit
         ======================================== -->
    <footer class="page-footer">
        <p>Vibe Coded by <a href="mailto:kevinmkolb@gmail.com">Kevin Kolb</a></p>
        <p class="visitor-count">Visitors: <span id="visitorCount">0</span></p>
    </footer>
</body>
</html>
