<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="tv.ico">
    <link rel="stylesheet" href="style.css">
    <title>The Cable Guide Channel CableGuide.tv</title>
<script>
/* ============================================================================
   CONFIGURATION
   ============================================================================ */
// TV Media API Key - used for fetching live broadcast channel data
const TV_MEDIA_API_KEY = "f60c4964b9cbd51e78e0b1739b00775b"; // Keep this private

// Display constants
const MINUTES_PER_TIME_SLOT = 30;
const PIXELS_PER_TIME_SLOT = 140;
const TIME_SLOTS_TO_DISPLAY = 8;

/* ============================================================================
   INITIALIZATION
   ============================================================================ */
document.addEventListener("DOMContentLoaded", () => {
    loadGuide();
    updateClock();
    setInterval(updateClock, 1000);
    updateVisitorCount();
    initializeSpeedControl();
});

/* ============================================================================
   SPEED CONTROL
   Controls playback speed of video player
   ============================================================================ */
function initializeSpeedControl() {
    const speedSlider = document.getElementById("speedSlider");
    const speedValue = document.getElementById("speedValue");

    if (speedSlider && speedValue) {
        speedSlider.addEventListener("input", (e) => {
            const speed = parseFloat(e.target.value);
            speedValue.textContent = `${speed}x`;

            // Update video speed (YouTube iframe API)
            const iframe = document.querySelector(".screen-wrapper iframe");
            if (iframe) {
                // Note: Speed control requires YouTube iframe API
                console.log(`Speed changed to ${speed}x`);
            }
        });
    }
}

/* ============================================================================
   CLOCK AND DATE DISPLAY
   Updates the clock/date display in top-right corner every second
   ============================================================================ */
function updateClock() {
    const clockElement = document.getElementById("clock");
    const topClockElement = document.getElementById("topClock");
    const currentTime = new Date();

    // Format time as HH:MM AM/PM
    const timeString = currentTime.toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit"
    });

    // Format date as "Day, Mon DD"
    const dateString = currentTime.toLocaleDateString(undefined, {
        weekday: "short",
        month: "short",
        day: "numeric"
    });

    // Display time on top, date below in smaller font (for guide header clock)
    if (clockElement) {
        clockElement.innerHTML = `${timeString}<br><span style="font-size: 14px;">${dateString}</span>`;
    }

    // Display inline for top control bar
    if (topClockElement) {
        topClockElement.textContent = `${dateString} ${timeString}`;
    }
}

/* ============================================================================
   VISITOR COUNTER
   Tracks and displays visitor count using localStorage
   ============================================================================ */
function updateVisitorCount() {
    const STORAGE_KEY = 'cableGuideVisitors';
    const visitorCountElement = document.getElementById('visitorCount');

    // Get current count from localStorage
    let visitorCount = localStorage.getItem(STORAGE_KEY);

    // Initialize or increment
    visitorCount = visitorCount === null ? 1 : parseInt(visitorCount) + 1;

    // Save and display
    localStorage.setItem(STORAGE_KEY, visitorCount);
    if (visitorCountElement) {
        visitorCountElement.textContent = visitorCount;
    }
}

/* ============================================================================
   TIME FORMATTING UTILITIES
   Converts 24-hour time to 12-hour AM/PM format
   ============================================================================ */
function formatTimeLabel(timeString) {
    const [hours, minutes] = timeString.split(":");
    let hour24 = parseInt(hours, 10);

    // Determine AM/PM
    const period = hour24 >= 12 ? "PM" : "AM";

    // Convert to 12-hour format
    const hour12 = hour24 % 12 || 12;

    return `${hour12}:${minutes} ${period}`;
}

/* ============================================================================
   GUIDE DATA LOADING
   Loads channel data from XML (scraped) and API sources, merges them
   ============================================================================ */
async function loadGuide() {
    try {
        // STEP 1: Load guide.xml first (scraped channels - highest priority)
        let xmlChannels = [];
        try {
            const xmlRes = await fetch("guide.xml");
            if (xmlRes.ok) {
                const xmlText = await xmlRes.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");

                const channelElements = xmlDoc.querySelectorAll("channel");
                xmlChannels = Array.from(channelElements).map(ch => {
                    const number = ch.querySelector("number")?.textContent || "";
                    const name = ch.querySelector("name")?.textContent || "";
                    const type = ch.getAttribute("type") || "unknown";
                    const source = ch.getAttribute("source") || "unknown";
                    const shows = Array.from(ch.querySelectorAll("show")).map(show => ({
                        start: show.getAttribute("start"),
                        duration: parseInt(show.getAttribute("duration") || "30"),
                        title: show.textContent,
                        description: show.getAttribute("description") || ""
                    }));

                    return {
                        channelNumber: number,
                        callSign: name,
                        network: name,
                        type: type,
                        source: source,
                        listings: shows.map(show => ({
                            title: show.title,
                            shortDescription: show.description,
                            startTime: new Date(), // Will be calculated from time slots
                            duration: show.duration
                        })),
                        dataSource: "xml" // Mark as loaded from XML file
                    };
                });
                console.log(`üìÑ Loaded ${xmlChannels.length} channels from guide.xml`);

                // Log channel sources
                console.log("\nüì∫ Channel Sources:");
                xmlChannels.forEach(ch => {
                    console.log(`  ${ch.channelNumber} (${ch.name}): type="${ch.type}", source="${ch.source}"`);
                });
            }
        } catch (xmlErr) {
            console.log("‚ö†Ô∏è Could not load guide.xml, will try API only");
        }

        // STEP 2: Try to load API channels (with error handling)
        let apiChannels = [];
        try {
            const zip = "70130"; // New Orleans

            // Get available lineups for ZIP code
            const lineupResponse = await fetch(
                `https://api.tvmedia.ca/tv/v4/lineups?postalCode=${encodeURIComponent(zip)}&api_key=${TV_MEDIA_API_KEY}`
            );

            if (lineupResponse.ok) {
                const lineups = await lineupResponse.json();
                if (Array.isArray(lineups) && lineups.length > 0) {
                    const lineupID = lineups[0].lineupID;

                    // Get channel grid listings for this lineup
                    const listingsResponse = await fetch(
                        `https://api.tvmedia.ca/tv/v4/lineups/${encodeURIComponent(lineupID)}/listings/grid?api_key=${TV_MEDIA_API_KEY}`
                    );

                    if (listingsResponse.ok) {
                        const grid = await listingsResponse.json();
                        apiChannels = Array.isArray(grid.channels) ? grid.channels : [];

                        // Filter API channels that have listings
                        apiChannels = apiChannels.filter(ch => {
                            const listings = Array.isArray(ch.listings) ? ch.listings : [];
                            return listings.length > 0;
                        }).map(ch => ({
                            ...ch,
                            source: "api" // Mark as API channel
                        }));

                        console.log(`üåê Loaded ${apiChannels.length} channels from API`);
                    }
                }
            }
        } catch (apiErr) {
            console.log("‚ö†Ô∏è Could not load API channels:", apiErr.message);
            console.log("üì∫ Using XML channels only");
        }

        // STEP 4: Merge channels - XML channels override API channels with same call sign/network
        const channelMap = new Map();

        // First, add all API channels
        apiChannels.forEach(ch => {
            const key = (ch.callSign || ch.network || ch.networkName || "").toUpperCase().replace(/[^A-Z0-9]/g, '');
            if (key) {
                channelMap.set(key, ch);
            }
        });

        // Then, override with XML channels (higher priority)
        xmlChannels.forEach(ch => {
            const key = (ch.callSign || ch.network || "").toUpperCase().replace(/[^A-Z0-9]/g, '');
            if (key) {
                if (channelMap.has(key)) {
                    console.log(`üîÑ Overriding API channel ${key} with scraped data`);
                }
                channelMap.set(key, ch);
            }
        });

        // Convert back to array
        let channels = Array.from(channelMap.values());

        // Sort by channel number for better organization
        channels.sort((a, b) => {
            const numA = parseInt(a.channelNumber) || 0;
            const numB = parseInt(b.channelNumber) || 0;
            return numA - numB;
        });

        if (channels.length === 0) {
            throw new Error("No channels available - check guide.xml and API connection");
        }

        console.log(`‚úÖ Total ${channels.length} channels (${xmlChannels.length} scraped, ${apiChannels.length} API)`);

        // STEP 5: Ads carousel removed per user request

        // STEP 6: Display YouTube playlist in movie screen player
        try {
            const videosContainer = document.getElementById("videosContainer");

            // YouTube playlist ID
            const playlistId = "PL5PIyBfx10wEPYJtYrZL0JBReXx-u9-mK";

            // Generate random starting index (assuming playlist has ~50 videos)
            const randomIndex = Math.floor(Math.random() * 50);

            // Create large movie screen player with playlist
            videosContainer.innerHTML = `
                <div class="movie-screen">
                    <div class="screen-wrapper">
                        <iframe
                            src="https://www.youtube.com/embed?listType=playlist&list=${playlistId}&index=${randomIndex}&autoplay=1&mute=0&loop=1&shuffle=1"
                            title="Cable Guide Cinema"
                            frameborder="0"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                            allowfullscreen>
                        </iframe>
                    </div>
                </div>
            `;

            videosContainer.style.display = 'flex';

            // Show the media layout container
            const mediaLayout = document.querySelector('.media-layout');
            if (mediaLayout) {
                mediaLayout.style.display = 'flex';
            }

            console.log(`üé¨ Loaded YouTube playlist player`);
        } catch (err) {
            console.log("‚ö†Ô∏è Could not load video player");
        }

        // STEP 7: Build header - ad banner and time slots
        updateChannelCount(channels.length);

        function updateChannelCount(total) {
            document.getElementById("adSection").innerHTML =
                `<div class="ad-text">CABLE TV GUIDE ‚Äì <span id="visibleChannelCount">${total}</span> / ${total} CHANNELS</div>`;
        }

        // Store for later use
        window.updateChannelCount = updateChannelCount;
        window.totalChannels = channels.length;

        document.getElementById("guideHeader").style.display = "flex";

        // Build 8 x 30-minute time slots starting from current half-hour
        const timeSlotsEl = document.getElementById("timeSlots");
        const now = new Date();
        const start = new Date(now);
        start.setMinutes(now.getMinutes() < 30 ? 0 : 30, 0, 0);

        let timeHTML = "";
        for (let i = 0; i < 8; i++) {
            const slotTime = new Date(start.getTime() + i * 30 * 60000);
            const hh = String(slotTime.getHours()).padStart(2, "0");
            const mm = String(slotTime.getMinutes()).padStart(2, "0");
            const label = formatTimeLabel(`${hh}:${mm}`);
            timeHTML += `<div class="time-slot">${label}</div>`;
        }
        timeSlotsEl.innerHTML = timeHTML;

        // STEP 8: Build channel filter checkboxes
        const filtersEl = document.getElementById("channelFilters");
        const filterHTML = channels.map((ch, idx) => {
            const number = ch.channelNumber || "";
            const callSign = ch.callSign || "";
            const network = ch.network || ch.networkName || "";
            const label = [number, callSign || network].filter(Boolean).join(" - ");
            return `
                <div class="filter-item">
                    <input type="checkbox" checked id="filter-${idx}" onchange="toggleChannel(${idx})">
                    <label for="filter-${idx}">${label}</label>
                </div>`;
        }).join("");
        filtersEl.innerHTML = filterHTML;

        // STEP 9: Build guide rows (channel listings)
        const guideScroll = document.getElementById("guideScroll");
        guideScroll.innerHTML = "";

        const guideHTML = channels.map(channel => {
            // Extract channel information
            const channelNumber = channel.channelNumber || "";
            const callSign = channel.callSign || "";
            const networkName = channel.network || channel.networkName || "";
            const channelLabel = callSign || networkName || channelNumber;
            const listings = Array.isArray(channel.listings) ? channel.listings : [];

            const showsHTML = listings.map(listing => {
                const startTime = new Date(listing.startTime);
                const endTime = listing.endTime
                    ? new Date(listing.endTime)
                    : new Date(startTime.getTime() + (listing.duration || 30) * 60000);

                // Calculate show width based on duration
                const durationMinutes = Math.max(15, (endTime - startTime) / 60000); // Minimum 15 minutes
                const showWidthPixels = (durationMinutes / MINUTES_PER_TIME_SLOT) * PIXELS_PER_TIME_SLOT;

                const title =
                    listing.title ||
                    listing.episodeTitle ||
                    listing.seriesTitle ||
                    "Program";

                // Build more detailed description
                let desc = listing.shortDescription || listing.longDescription || "";

                // Add episode info if available
                if (listing.episodeTitle && listing.episodeTitle !== title) {
                    desc = `${listing.episodeTitle}. ${desc}`;
                }
                if (listing.seasonNumber && listing.episodeNumber) {
                    desc = `S${listing.seasonNumber}E${listing.episodeNumber} - ${desc}`;
                }

                // Add rating and year if available
                const extras = [];
                if (listing.rating) extras.push(listing.rating);
                if (listing.year) extras.push(listing.year);
                if (extras.length > 0) {
                    desc = `${desc} (${extras.join(', ')})`;
                }

                const safeDescription = desc
                    .replace(/&/g, "&amp;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");

                const tooltipAttr = safeDescription
                    ? ` data-description="${safeDescription}"`
                    : "";

                return `
                    <div class="show-block"
                         style="min-width:${showWidthPixels}px"
                         ${tooltipAttr}>
                        ${title}
                    </div>`;
            }).join("");

            // Add source indicator for XML channels
            const isXmlSource = channel.dataSource === "xml";
            const sourceIcon = isXmlSource ? "‚≠ê" : "";

            // Build full channel name for tooltip
            const fullChannelName = [channelNumber, callSign, networkName]
                .filter(Boolean)
                .filter((v, i, a) => a.indexOf(v) === i) // Remove duplicates
                .join(" - ");

            const safeChannelName = fullChannelName
                .replace(/&/g, "&amp;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");

            return `
                <div class="channel-row" data-source="${channel.dataSource || 'api'}">
                    <div class="channel-number" data-channel-name="${safeChannelName}">${sourceIcon}${channelNumber}</div>
                    <div class="shows-container">
                        ${showsHTML}
                    </div>
                </div>`;
        }).join("");

        // STEP 10: Duplicate content for seamless infinite scroll
        guideScroll.innerHTML = guideHTML + guideHTML;

        // STEP 11: Initialize auto-scroll and drag functionality
        initializeScrolling();

    } catch (err) {
        console.error(err);
        document.getElementById("adSection").innerHTML =
            '<div class="loading">ERROR LOADING GUIDE DATA</div>';
    }
}

/* ============================================================================
   AUTO-SCROLL AND DRAG FUNCTIONALITY
   Provides infinite auto-scrolling with click-and-drag manual control
   ============================================================================ */

// Auto-scroll configuration
let autoScrollSpeedPixelsPerFrame = 0.5;
let scrollAnimationFrameId = null;

// Drag state variables
let isDraggingGuide = false;
let dragStartY = 0;
let scrollPositionAtDragStart = 0;

function initializeScrolling() {
    const guideContainer = document.querySelector('.guide-container');
    const guideScrollElement = document.getElementById('guideScroll');

    if (!guideContainer || !guideScrollElement) return;

    // Auto-scroll animation loop
    function autoScroll() {
        if (!isDraggingGuide) {
            guideContainer.scrollTop += autoScrollSpeedPixelsPerFrame;

            // Infinite loop: reset to beginning when halfway through duplicated content
            const halfHeight = guideScrollElement.scrollHeight / 2;
            if (guideContainer.scrollTop >= halfHeight) {
                guideContainer.scrollTop = 0;
            }
        }
        scrollAnimationFrameId = requestAnimationFrame(autoScroll);
    }

    // Start auto-scroll animation
    if (scrollAnimationFrameId) {
        cancelAnimationFrame(scrollAnimationFrameId);
    }
    autoScroll();

    // Mouse down: start dragging
    guideContainer.addEventListener('mousedown', (e) => {
        isDraggingGuide = true;
        dragStartY = e.pageY - guideContainer.offsetTop;
        scrollPositionAtDragStart = guideContainer.scrollTop;
        guideContainer.classList.add('dragging');
    });

    // Mouse leave: stop dragging
    guideContainer.addEventListener('mouseleave', () => {
        isDraggingGuide = false;
        guideContainer.classList.remove('dragging');
    });

    // Mouse up: stop dragging
    guideContainer.addEventListener('mouseup', () => {
        isDraggingGuide = false;
        guideContainer.classList.remove('dragging');
    });

    // Mouse move: handle dragging
    guideContainer.addEventListener('mousemove', (e) => {
        if (!isDraggingGuide) return;
        e.preventDefault();

        const currentY = e.pageY - guideContainer.offsetTop;
        const dragDistance = (currentY - dragStartY) * 2; // Scroll speed multiplier
        guideContainer.scrollTop = scrollPositionAtDragStart - dragDistance;

        // Maintain infinite loop during drag
        const halfHeight = guideScrollElement.scrollHeight / 2;
        if (guideContainer.scrollTop >= halfHeight) {
            // Scrolled past halfway, jump back to start
            guideContainer.scrollTop = guideContainer.scrollTop - halfHeight;
            scrollPositionAtDragStart = guideContainer.scrollTop;
            dragStartY = currentY;
        } else if (guideContainer.scrollTop < 0) {
            // Scrolled before start, jump to halfway point
            guideContainer.scrollTop = halfHeight + guideContainer.scrollTop;
            scrollPositionAtDragStart = guideContainer.scrollTop;
            dragStartY = currentY;
        }
    });
}

/* ============================================================================
   CHANNEL FILTER CONTROLS
   Toggle individual channel visibility in the guide
   ============================================================================ */

function toggleChannel(channelIndex) {
    const allChannelRows = document.querySelectorAll(".channel-row");
    const totalUniqueChannels = allChannelRows.length / 2; // Content is duplicated for infinite scroll

    // Toggle both the original row and its duplicate
    const originalRow = allChannelRows[channelIndex];
    const duplicateRow = allChannelRows[channelIndex + totalUniqueChannels];

    if (originalRow) {
        originalRow.classList.toggle("hidden");
    }
    if (duplicateRow) {
        duplicateRow.classList.toggle("hidden");
    }

    // Update visible channel count display
    updateVisibleChannelCount();
}

function updateVisibleChannelCount() {
    const allChannelRows = document.querySelectorAll(".channel-row");
    const totalUniqueChannels = allChannelRows.length / 2; // Content is duplicated

    // Count visible channels (only first half, ignore duplicates)
    const visibleChannels = Array.from(allChannelRows)
        .slice(0, totalUniqueChannels)
        .filter(row => !row.classList.contains("hidden"))
        .length;

    // Update display
    const visibleCountElement = document.getElementById("visibleChannelCount");
    if (visibleCountElement) {
        visibleCountElement.textContent = visibleChannels;
    }
}

function toggleControls() {
    const panel = document.getElementById("controlsPanel");
    panel.classList.toggle("collapsed");
}

/* ============================================================================
   FULLSCREEN FUNCTIONALITY
   Toggle fullscreen mode for the TV guide container
   ============================================================================ */
function toggleFullscreen() {
    const container = document.querySelector('.tv-container');
    const btn = document.getElementById('fullscreenBtn');

    if (!document.fullscreenElement &&
        !document.webkitFullscreenElement &&
        !document.mozFullScreenElement &&
        !document.msFullscreenElement) {

        // Enter fullscreen
        if (container.requestFullscreen) {
            container.requestFullscreen();
        } else if (container.webkitRequestFullscreen) {
            container.webkitRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
            container.mozRequestFullScreen();
        } else if (container.msRequestFullscreen) {
            container.msRequestFullscreen();
        }

        // Update button icon
        btn.querySelector('.fullscreen-icon').textContent = '‚õ∂';
        btn.title = 'Exit Fullscreen';

    } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }

        // Update button icon
        btn.querySelector('.fullscreen-icon').textContent = '‚õ∂';
        btn.title = 'Toggle Fullscreen';
    }
}

// Listen for fullscreen changes (e.g., when user presses ESC)
document.addEventListener('fullscreenchange', updateFullscreenButton);
document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
document.addEventListener('mozfullscreenchange', updateFullscreenButton);
document.addEventListener('MSFullscreenChange', updateFullscreenButton);

function updateFullscreenButton() {
    const btn = document.getElementById('fullscreenBtn');
    if (!btn) return;

    const isFullscreen = document.fullscreenElement ||
                        document.webkitFullscreenElement ||
                        document.mozFullScreenElement ||
                        document.msFullscreenElement;

    if (isFullscreen) {
        btn.querySelector('.fullscreen-icon').textContent = '‚õ∂';
        btn.title = 'Exit Fullscreen (ESC)';
    } else {
        btn.querySelector('.fullscreen-icon').textContent = '‚õ∂';
        btn.title = 'Toggle Fullscreen';
    }
}

/* ============================================================================
   AD CAROUSEL - Removed per user request
   ============================================================================ */
</script>
</head>
<body>
    <!-- ========================================
         SWISS DESIGN HEADER
         Clean, minimal header with branding
         ======================================== -->
    <header class="swiss-header">
        <div class="swiss-container">
            <h1 class="swiss-title">Cable Guide</h1>
            <p class="swiss-tagline">TV: Back in the Box</p>
        </div>
    </header>

    <!-- ========================================
         CHANNEL FILTERS SECTION
         Collapsible panel for toggling channels
         ======================================== -->
    <div class="controls" id="controlsPanel">
        <div class="controls-header" onclick="toggleControls()">
            <h3>
                <span>üéõÔ∏è</span>
                <span>CHANNELS</span>
            </h3>
            <span class="toggle-arrow">‚ñº</span>
        </div>
        <div class="channel-filters" id="channelFilters">
            <!-- Channel checkboxes populated dynamically -->
        </div>
    </div>

    <!-- ========================================
         TV GUIDE SECTION
         Main guide display with auto-scroll
         ======================================== -->
    <div class="tv-container">
        <div class="screen">
            <!-- Visual effects overlay -->
            <div class="scanlines"></div>

            <!-- Advertisement/status banner -->
            <div class="ad-section" id="adSection">
                <div class="loading">LOADING GUIDE DATA...</div>
            </div>

            <!-- Media Controls Bar -->
            <div class="media-controls-bar">
                <div class="clock" id="topClock"></div>
                <button class="fullscreen-btn" id="topFullscreenBtn" onclick="toggleFullscreen()" title="Toggle Fullscreen">
                    <span class="fullscreen-icon">‚õ∂</span>
                </button>
                <div class="speed-control">
                    <label for="speedSlider">Speed:</label>
                    <input type="range" id="speedSlider" min="0.25" max="2" step="0.25" value="1">
                    <span id="speedValue">1x</span>
                </div>
            </div>

            <!-- YouTube Videos Section with Future Space -->
            <div class="media-layout">
                <div class="videos-container" id="videosContainer">
                    <!-- Video players populated dynamically -->
                </div>
                <div class="future-container" id="futureContainer">
                    <!-- Reserved for future use -->
                </div>
            </div>

            <!-- Main scrollable guide container -->
            <!-- Features: auto-scroll, infinite loop, click-and-drag -->
            <div class="guide-container">
                <!-- Time slots header (sticky) -->
                <div class="guide-header" id="guideHeader" style="display: none;">
                    <!-- Fullscreen button -->
                    <button class="fullscreen-btn" id="fullscreenBtn" onclick="toggleFullscreen()" title="Toggle Fullscreen">
                        <span class="fullscreen-icon">‚õ∂</span>
                    </button>

                    <div class="channel-spacer"></div>

                    <div class="time-slots-container">
                        <div class="time-slots" id="timeSlots">
                            <!-- Time slots populated dynamically -->
                        </div>
                    </div>

                    <!-- Clock and date -->
                    <div class="clock" id="clock"></div>
                </div>

                <div class="guide-scroll" id="guideScroll">
                    <!-- Channel rows populated dynamically -->
                    <!-- Content is duplicated for seamless infinite scroll -->
                </div>
            </div>
        </div>
    </div>

    <!-- ========================================
         FOOTER
         Developer credit
         ======================================== -->
    <footer class="page-footer">
        <p>Vibe Coded by <a href="mailto:kevinmkolb@gmail.com">Kevin Kolb</a></p>
        <p class="visitor-count">Visitors: <span id="visitorCount">0</span></p>
    </footer>
</body>
</html>
